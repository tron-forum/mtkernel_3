# μT-Kernel3.0 RXv2マイコン向け実装仕様書 <!-- omit in toc -->
## Version.02.00.00 <!-- omit in toc -->
## 2023.12.01 <!-- omit in toc -->

<div class="page"/>

# 目次 <!-- omit in toc -->
- [1. 概要](#1-概要)
  - [1.1. 目的](#11-目的)
  - [1.2. 関連ドキュメント](#12-関連ドキュメント)
  - [1.3. ソースコード構成](#13-ソースコード構成)
- [2. 基本実装仕様](#2-基本実装仕様)
  - [2.1. マイコン関連](#21-マイコン関連)
    - [2.1.1. 実行モードと保護レベル](#211-実行モードと保護レベル)
    - [2.1.2. CPUレジスタ](#212-cpuレジスタ)
    - [2.1.3. コプロセッサ対応](#213-コプロセッサ対応)
  - [2.2. メモリ関連](#22-メモリ関連)
    - [2.2.1. メモリモデル](#221-メモリモデル)
    - [2.2.2. スタック](#222-スタック)
    - [2.2.3. OS内の動的メモリ管理](#223-os内の動的メモリ管理)
  - [2.3. 割込みおよび例外関係](#23-割込みおよび例外関係)
    - [2.3.1. マイコンの割込みおよび例外](#231-マイコンの割込みおよび例外)
    - [2.3.2. 割込み関連定義](#232-割込み関連定義)
    - [2.3.3. ベクタテーブル](#233-ベクタテーブル)
      - [2.3.3.1. 割込み優先度](#2331-割込み優先度)
    - [2.3.4. 多重割込み対応](#234-多重割込み対応)
    - [2.3.5. クリティカルセクション](#235-クリティカルセクション)
    - [2.3.6. μT-Kenrel/OSの割込み管理機能](#236-μt-kenrelosの割込み管理機能)
    - [2.3.7. μT-Kernel/SMの割込み管理機能](#237-μt-kernelsmの割込み管理機能)
    - [2.3.8. OS管理外割込み](#238-os管理外割込み)
  - [2.4. その他の例外](#24-その他の例外)
- [3. システムの起動](#3-システムの起動)
  - [3.1. 起動処理](#31-起動処理)
    - [3.1.1. リセットハンドラ](#311-リセットハンドラ)
    - [3.1.2. OS初期化処理](#312-os初期化処理)
- [4. システムの終了と再起動](#4-システムの終了と再起動)
  - [4.1. 終了処理と再起動処理](#41-終了処理と再起動処理)
- [5. タスク](#5-タスク)
  - [5.1. タスクの処理ルーチン](#51-タスクの処理ルーチン)
  - [5.2. タスク・コンテキスト情報](#52-タスクコンテキスト情報)
- [6. 時間管理機能](#6-時間管理機能)
  - [6.1. システムタイマ](#61-システムタイマ)
- [7. 変更履歴](#7-変更履歴)

<div class="page"/>

# 1. 概要
## 1.1. 目的
本書はRXv2コアを使用したマイコン向けのμT-Kernel3.0の実装仕様を記す。
対象は、トロンフォーラムから公開されているμT-Kernel 3.0(V3.00.07)のうち、RXv2コアを使用したマイコン向けの実装部分である。
ハードウェアに依存しない共通の実装仕様は「μT-Kernel3.0共通実装仕様書」を参照、個々のマイコンの実装仕様は各マイコン向けの実装仕様書を参照のこと。

以降、単にOSと称する場合はμT-Kenrel3.0を示し、本実装と称する場合、前述のソースコードの実装を示す。

## 1.2. 関連ドキュメント
以下に関連するドキュメントを記す。この他にRXv2コアを使用した各種マイコンの実装仕様書がある。

| 分類      | 名称                                                          | 発行             |
| --------- | ------------------------------------------------------------- | ---------------- |
| OS        | μT-Kernel 3.0仕様書(Ver.3.00.01)<br>TEF020-S004-03.00.01      | トロンフォーラム |
| OS        | μT-Kernel3.0共通実装仕様書(Ver.2.00.00)<br>TEF033-W002-211115 | トロンフォーラム |
| T-Monitor | T-Monitor仕様書<br>TEF020-S002-01.00.01                       | トロンフォーラム |

## 1.3. ソースコード構成
機種依存定義sysdependディレクトリ下の本実装のディレクトリ構成を以下に示す。名称に(*)の点いたディレクトリが本実装の対象である。

```
─ sysdepend                   ハードウェア依存部
     ├ <ターゲット名1>             ターゲット名1のシステム依存部
     ├       ：
     ├ <ターゲット名n>             ターゲット名nのシステム依存部
     └ cpu                         CPU依存部
          ├ <CPU1>                      CPU1依存部	
          ├     ：
          └ <CPUn>                      CPUn依存部
          └ core                        CPUコア依存部
               ├ rxv2                       RXv2コア依存部(*)
               ├    ：
               └ <core n>                   コアn依存部
```
<div class="page"/>

# 2. 基本実装仕様
## 2.1. マイコン関連
### 2.1.1. 実行モードと保護レベル
RXv2コアは、プログラムの動作モードとして、スーパーバイザモードとユーザモードの二つのプロセッサモードを持つ。
本実装では、実行モードはスーパーバイザモードのみを使用する。

OSが提供する保護レベルは、実行モードがスーパーバイザモードのみなので、すべて保護レベル0とみなす。カーネルオブジェクトに対して保護レベル1～3を指定しても保護レベル0を指定されたものとして扱う。
プロファイルTK_MEM_RNG0~TK_MEM_RNG3はすべて0が返される。

### 2.1.2. CPUレジスタ
OSのAPI (tk_set_reg、 tk_get_reg) を用いて実行中のタスクのコンテキストのレジスタ値を操作できる。
APIで使用するマイコンのレジスタのセットは以下のファイルで定義される。

    include/tk/sysdepend/cpu/core/rxv2/cpudef.h

(1) 汎用レジスタ
```
typedef struct t_regs {
    VW  r[15];      /* General purpose register R1-R15 */
} T_REGS;
```

(2) 例外時に保存されるレジスタ T_EIT
```
typedef struct t_eit {
    void    *pc;    /* Program counter */
    VW      psw;    /* Status register */
} T_EIT;
```
(3) 制御レジスタ T_CREGS
```
typedef struct t_cregs {
    void    *ssp;   /* System stack pointer R0 */
} T_CREGS;
```

OSのAPIによって操作されるのは、実際にはスタック上に退避されたレジスタの値である。よって、実行中のタスクに操作することはできない（OS仕様上、自タスクへの操作、またはタスク独立部からのAPI呼出しは禁止されている）。

### 2.1.3. コプロセッサ対応
本マイコンはFPUおよびDSPの機能を有する。コンフィギュレーションUSE_FPUおよびUSE_DSPにより、OSのコプロセッサ対応機能を有効とすることができる。

(1) FPU
コンフィギュレーションUSE_FPUをTRUEに指定（初期値TRUE）すると、OSでFPU対応の機能が有効となり、コプロセッサ番号0が割り当てられる。
FPUが有効の場合、タスク属性にTA_FPUまたはTA_COP0が指定可能となる。
FPUは32ビットの1個の専用レジスタ（FPSWレジスタ）を持つ。本OS実装では、FPUが有効の場合は、割込みハンドラ実行やタスクのディスパッチの際には必ずFPU用レジスタをスタックに退避する。よって、TA_FPU属性の指定に関わらず各タスクやハンドラ内でFPUは使用が可能である。ただし、互換性や移植性の観点から、FPUを使用するタスクはTA_FPU属性を指定することを推奨する。

(2) DSP
コンフィギュレーションUSE_DSPをTRUEに指定（初期値FALSE）すると、OSでDSP対応の機能が有効となり、コプロセッサ番号1が割り当てられる。
DSPが有効の場合、タスク属性にTA_COP1が指定可能となる。
DPSは72ビットの2個の専用レジスタ(ACC0, ACC1)を持つ。本OS実装では、DSPが有効の場合は、タスクのディスパッチの際には必ずDSP用レジスタをスタックに退避する。よって、TA_COP1属性の指定に関わらず各タスクでDSPは使用が可能である。ただし、互換性や移植性の観点から、DSPを使用するタスクはTA_COP1属性を指定することを推奨する。
なお、割込みハンドラ実行の際にはDSP用レジスタの退避は行われない。よって、各ハンドラではDSP命令を使用してはいけない。もし、DSP命令を使用したい場合はハンドラの実行時にレジスタの退避と復帰の処理を行わなければならない。

プロファイルUSE_FPUおよびUSE_DSPが有効な場合、OSのAPI (tk_set_cop、 tk_get_cop) を用いて実行中のタスクのコンテキストのコプロセッサ用レジスタ値を操作できる。
コプロセッサ用のレジスタは以下のファイルで定義される。

    include/tk/sysdepend/cpu/core/rxv2/cpudef.h 

```
typedef struct t_cregs {
	void	*ssp;	/* System stack pointer R0 */
} T_CREGS;

/*
 * Coprocessor registers
 */

typedef struct t_cop0reg {
	VW	fpsw;       /* Floating Point Status register */
} T_COP0REG;

typedef struct t_cop1reg {
    UW  acc0lo;
    UW  acc0hi;
    VW  acc0gu;     /* Accumulator 0 */
    UW  acc1lo;
    UW  acc1hi;
    VW  acc1gu;     /* Accumulator 1 */
} T_COP1REG;

typedef struct t_copregs {
    T_COP0REG   cop0;   /* COP0: FPU */
    T_COP1REG   cop1;   /* COP1: DSP */
} T_COPREGS;
```

OSのAPIによって操作されるのは、実際にはスタック上に退避されたレジスタの値である。よって、実行中のタスクに操作することはできない（OS仕様上、自タスクへの操作、またはタスク独立部からのAPI呼出しは禁止されている）。

## 2.2. メモリ関連
### 2.2.1. メモリモデル
RXv2コアは32bitのアドレス空間を有する。MMU(Memory Management Unit：メモリ管理ユニット)は有さず、単一の物理アドレス空間のみである。
本実装では、プログラムは一つの実行オブジェクトに静的にリンクされていることを前提とする。OSとユーザプログラム（アプリケーションなど）は静的にリンクされており、関数呼び出しが可能とする。

### 2.2.2. スタック
マイコンには、ISP(割込みスタックポインタ)とUSP(ユーザスタックポインタ)の二種類のスタックポインタが存在する。ただし、本実装ではISPのみを使用し、USPは使用しない。
本実装で使用するスタックには共通仕様に従い以下の種類がある。

(1) タスクスタック
(2) 例外スタック
(3) テンポラリスタック

### 2.2.3. OS内の動的メモリ管理
OS内の動的メモリ管理に使用するOS管理メモリ領域は、以下のように定められる。

(1) OS管理メモリ領域の開始アドレス
コンフィギュレーションCNF_SYSTEMAREA_TOPの値が0の場合、RAM上のプログラムのデータ領域(BSS領域)の最終アドレスの次のアドレスが、開始アドレスとなる。
値が0以外の場合は、その値が開始アドレスとなる。ただし、その値がRAM上のプログラムのデータ領域(BSS領域)の最終アドレス以下の場合は、BSS領域の最終アドレスの次のアドレスが開始アドレスとなる。つまり、BSS領域と重複することはない。

(2) OS管理メモリ領域の終了アドレス
コンフィギュレーションCNF_SYSTEMAREA_ENDの値が0の場合、RAM上の例外スタックの開始アドレスの前のアドレスが、終了アドレスとなる。
値が0以外の場合は、その値が終了アドレスとなる。ただし、その値が例外スタックの開始アドレス以上の場合は、例外スタックの開始アドレスの前のアドレスが開始アドレスとなる。つまり、例外スタックの領域と重複することはない。

##  2.3. 割込みおよび例外関係
### 2.3.1. マイコンの割込みおよび例外
RXv2コアには以下の例外が存在する。OSの割込み管理機能が管理するのは、割込みと無条件トラップのみである。

| 例外番号                   | 例外の種別 | 備考                     |
| -------------------------- | ---------- | ------------------------ |
| リセット                   | 1          | OSで使用                 |
| ノンマスカブル割込み(NMI)  | 2          |
| 割込み                     | 3          | OSの割込み管理機能で管理 |
| アクセス例外（命令）       | 4          |                          |
| 未定義命令例外             | 5          |                          |
| 特権命令例外               | 5          |                          |
| 無条件トラップ             | 6          | OSの割込み管理機能で管理 |
| アクセス例外（オペランド） | 7          |                          |
| 浮動小数点例外             | 8          |                          |
※優先順位は数字が小さいほど高い。

### 2.3.2. 割込み関連定義
各マイコンについて、以下のハードウェア仕様に関わる割込み関連の定義を行う。

| 名称               | 意味                         |
| ------------------ | ---------------------------- |
| N_INTVEC0          | グループ割込み以外の割込み数 |
| N_GROUP_INT        | グループ割込み数 (※)         |
| N_INTVEC           | すべての割込み数             |
| INTPRI_MIN_INT_PRI | 割込みの最低優先度           |
| INTPRI_MAX_INT_PRI | 割込みの最高優先度           |
(※)グループ割込みが存在するマイコンのみ定義される

各定義の具体的な値は、各マイコンの実装仕様書を参照のこと。

###  2.3.3. ベクタテーブル
RXv2コアは、例外ベクタテーブルと割込みベクタテーブルを有する。また、OS内の割込みハンドラ管理用にHLL割込みハンドラテーブルが存在する。

(1) 例外ベクタテーブル
例外ベクタテーブルは、リセット、割込み、無条件トラップ以外の例外ハンドラのアドレスが設定される。
本実装では、例外ベクタテーブルは、以下のファイルにexvect_tblとして定義される。例外ベクタテーブルは、OSの機能により動的に変更されることはない。

	kernel/sysdepend/cpu/core/rxv2/vector_tbl.c

(2) 割込みベクタテーブル
割込みベクタテーブルは、割込みおよび無条件トラップの割込みハンドラのアドレスが設定される。
リセット時の割込みベクタテーブルはknl_int_vect_romとしてROM上に定義される。具体的には各マイコンの実装仕様書を参照のこと。
OSの初期化処理において、ROM上のベクターテーブルはRAM上にコピーされ、以降はそちらが使用される。RAM上のベクタテーブルは、以下のファイルにknl_int_vect_ramとして定義される。

	kernel/sysdepend/cpu/core/rxv2/interrupt.c

ただし、コンフィグレーションUSE_STATIC_IVTが1に設定されている場合は、ROM上のベクターテーブルが使用され続ける。USE_STATIC_IVTの初期値は0である。

(3) HLL割込みハンドラテーブル
TA_HLANG属性の割込みハンドラ（高級言語（C言語）で記述された割込みハンドラ）は、OS内の高級言語対応ルーチンを経由して呼び出される。TA_HLANG属性の割込みハンドラの実行アドレスは、HLL割込みハンドラテーブルに登録される。
リセット時のHLL割込みハンドラテーブルはknl_hll_inthdr_romとしてROM上に定義される。具体的には各マイコンの実装仕様書を参照のこと。
OSの初期化処理において、ROM上のHLL割込みハンドラテーブルはRAM上にコピーされ、以降そちらが使用される。RAM上のHLL割込みベクタテーブルは、以下のファイルにknl_hll_inthdr_ramとして定義される。

	kernel/sysdepend/cpu/core/rxv2/interrupt.c

#### 2.3.3.1. 割込み優先度
割込みコントローラ(ICU)は、割込み優先度を1～15の15段階に設定できる（優先度の数字の大きい方が優先度は高い）。
OSのAPIにより割込みは優先度1～15が割り当て可能である。ただし、最高優先度である15はOSの割込み処理を阻害するため、ユーザプログラムからの使用可能は許されない。よって、実際に割当て可能な外部割込みの優先度は、1～14の14段階である。

### 2.3.4. 多重割込み対応
OSの割込みの高級言語対応ルーチンは多重割込みに対応している。
高級言語対応ルーチンからTA_HLANG属性の割込みハンドラを実行する際に、その割込みより優先度の高い割込みは受付可能となる。よって、割込みハンドラ実行中により優先度の高い割込みが発生した場合は、割込みハンドラの実行が優先度の高い割込みハンドラに割り込まれる。
もし、割込みハンドラの実行中に他の割込みをマスクしたい場合はOSのAPIを使用し、割込みのマスクレベルを変更する必要がある。
なお、TA_ASM属性の割込みハンドラは、OSの高級言語対応ルーチンを介さないため、ハンドラのプログラム中で必要に応じて割込みコントローラの制御を行う必要がある。

###  2.3.5. クリティカルセクション
OSのAPI実行中などのクリティカルセクションでは、原則としてすべての優先度の割込みはマスクされる。ただし、割込み以外の例外はマスクされない。
本実装では、クリティカルセクションはCPUのPSWレジスタに最高割込み優先度INTPRI_MAX_EXTINT_PRIを設定することにより実現する。INTPRI_MAX_EXTINT_PRIは、本OSが管理する割込みの最高の割込み優先度であり、各マイコンにて定義される。各マイコンの実装仕様書を参照のこと。

### 2.3.6. μT-Kenrel/OSの割込み管理機能
μT-Kernel/OSの割込み管理機能は、割込みハンドラの管理を行う。
本実装では、割込み管理機能はマイコンの割込みおよび無条件トラップを管理対象とする。その他の例外については対応しない。
グループ割込みは、コンフィギュレーションUSE_GROUP_INTが有効(1)の場合に仕様可能となる（初期値は有効(1)）。
割込みハンドラに関して以下のように定める。

- 割込み番号
割込み番号0～255は、マイコンの割込み番号（ベクタ番号）と同一とする。
割込み番号256からは、グループ割込みの各要因は割り当てられる。
具体的な番号はマイコンのマニュアルを参照のこと。

- 割込みハンドラ属性
割込みハンドラは、TA_HLNG属性とTA_ASM属性のいずれかが登録時にしてできる。

TA_HLNG属性の割込みハンドラは、割込みの発生後、OSの高級言語対応ルーチンを経由して呼び出される。
高級言語対応ルーチンは以下にファイルにknl_hll_inthdrとして記述されている。

    kernel/sysdepend/cpu/core/rxv2/int_asm.S

高級言語対応ルーチンknl_hll_inthdrでは以下の処理が実行される。

(1) タスク独立部の設定
処理開始時にシステム変数knl_taskindpをインクリメントし、終了時にデクリメントする。本変数が0以上の値のとき、タスク独立部であることを示す。

(2) 多重割込み対応
処理開始時にシステム変数knl_int_nestをインクリメントし、終了時にデクリメントする。本変数は割込みのネスト数を記録する。

(3) スタックの切り替え
使用するスタックを例外スタックに切り替える。

(4) 割込みハンドラの実行
テーブルknl_hll_inthdr_ramに登録されている発生した割込みに該当する割込みハンドラを実行する。また、その際に多重割込みを有効とする。

TA_ASM属性の割込みハンドラは、マイコンの割込みベクタテーブルに直接登録される。よって、割込み発生時には、OSの処理を介さずに直接ハンドラが実行される。このため、TA_ASM属性の割込みハンドラからは、原則としてAPIなどのOS機能の使用が禁止される。ただし、前述のOSの高級言語対応ルーチンと同様の処理を行うことにより、OS機能の使用が可能となる。

- デフォルトハンドラ
割込みハンドラが未登録の状態で、割込みが発生した場合はデフォルトハンドラが実行される。デフォルトハンドラは、以下のファイルにDefault_Handler関数として定義されている。

    kernel/sysdepend/cpu/core/rxv2/exc_hdr.c

デフォルトハンドラは、プロファイルUSE_EXCEPTION_DBG_MSGを1に設定することにより、デバッグ用の情報を出力する。デバッグ情報は、T-Monitor互換ライブラリのコンソール出力に出力される。初期設定は1(有効)である。

必要に応じてユーザがデフォルトハンドラを記述することにより、未定義割込み発生時の処理を行うことができる。デフォルトハンドラはweak宣言がされているので、ユーザが同名の関数を作成しリンクすることにより、上書きすることができる。

- グループ割込み
グループ割込みは、一つのグループ割込みに対して、最大32本の割込み要求が割り当てられている。
本実装では、グループ割込みの各要因について、割込み番号256以降を割当て、それぞれに割り込みハンドラを登録可能とする。
各グループ割込みには、OSが用意したグループ割込みハンドラが登録されており、そのハンドラの処理で発生したグループ割込みの要因を調べ、対応する割込みハンドラを実行する。よって、グループ割込みの各要因も通常の割込みと同様に割込みハンドラが登録できる。
グループ割込みの各要因の割込みハンドラは、TA_HLNG属性のみが指定可能である。
なお、グループ割込み自体の割込みハンドラに対して、ユーザ定義の割込みハンドラを登録することも可能である。この場合は、割込み番号256以降に登録した割り込みハンドラは無効となる。

### 2.3.7. μT-Kernel/SMの割込み管理機能
μT-Kernel/SMの割込み管理機能は、CPUの割込み管理機能および割込みコントローラ(ICU)の制御を行う。
本機能の各APIの実装について以下に記す。

- CPU割込み制御
CPU割込み制御は、マイコンのPSWレジスタを制御して実現する。

① CPU割込みの禁止（DI）
CPU割込みの禁止(DI)は、PSWレジスタに最高割込み優先度INTPRI_MAX_INT_PRIを設定し、すべての割込みを禁止する。DIはdisint関数を呼ぶ出すマクロである。

② CPU割込みの許可（EI）
割込みの許可(EI)は、PSWレジスタの値をDI実行前に戻す。EIはsetint関数を呼び出すマクロである。

③ CPU内割込みマスクレベルの設定(SetCpuIntLevel)
CPU内割込みマスクレベルの設定(SetCpuIntLevel)は、PSWレジスタのプロセッサ割込み優先レベル(IPL)を設定する。
割込みマスクレベルは1から15の値が指定可能である。指定したマスクレベル以下の優先度の割込みはマスクされる。また、割込みマスクレベルにINTLEVEL_EIを指定された場合は、すべての割り込みは許可され、INTLEVEL_DIを指定した場合はすべての割込みは禁止される。

④ CPU内割込みマスクレベルの参照(GetCpuIntLevel)
CPU内割込みマスクレベルの取得(GetCpuIntLevel)は、PSWレジスタのプロセッサ割込み優先レベル(IPL)を参照する。

上記のAPIおよび関数は以下のファイルに記述される。

    lib/libtk/sysdepend/cpu/core/rxv2/int_rxv2.c

- 割込みコントローラ制御
マイコン内蔵の割込みコントローラ（ICU）の制御を行う。

① 割込みコントローラの割込み許可(EnableInt)
割込みコントローラ(ICUb)の割り込み要求許可レジスタ(IER)を設定し、指定された割込みを許可する。
同時に割り込み要因プライオリティレジスタ(IPR)に指定された割込み優先度を設定する。割込み優先度は1から14の値が使用可能である。
グループ割込み要因に割り当てられた割込み（割込み番号256以降）が指定された場合は、グループ割り込み要求許可レジスタを設定し、指定された割込み要因を有効とする。割込み優先度の指定は無視される。なお、元となるグループ割込み自体の許可は行わないので、グループ割込み要因に割り当てられた割込みを有効にする場合は、まずグループ割込み自体を本APIで有効にしなければならない。

② 割込みコントローラの割込み禁止(DisableInt)
割込みコントローラ(ICUb)の割り込み要求許可レジスタ(IER)を設定し、指定された割込みを禁止する。
グループ割込み要因に割り当てられた割込み（割込み番号256以降）は、グループ割り込み要求許可レジスタを設定し、指定された割込み要因を無効とする。なお、元となるグループ割込み自体は無効にしないので、必要であればグループ割込みに対して本APIを実行する必要がある。

③ 割込み発生のクリア(ClearInt)
割込みコントローラ(ICUb)の割り込み要求レジスタ(IR)を設定し、指定された割込みが保留されていればクリアする。
ただし、クリア可能な割込みはエッジ検出のみであり、また割込み要求先がDTCまたはDMACの場合はクリアしてはならない。
グループ割込み要因に割り当てられた割込み（割込み番号256以降）は、グループ割り込み要求クリアレジスタを設定し、指定された割込み要因をクリアとする。指定可能なグループ割込み要因はエッジ検出のみである。なお、元となるグループ割込み自体のクリアは行わないので、必要であればグループ割込みに対して本APIを実行する必要がある。

④ 割込みコントローラのEOI発行(EndOfInt)
本マイコンではEOIの発行は不要である。よって、EOI発行(EndOfInt)は何も実行しない関数として定義される。

⑤ 割込み発生の検査(CheckInt)
割込み発生の検査(CheckInt)は、割込みコントローラ(ICUb)の割り込み要求レジスタ(IR)を参照することにより実現する。
グループ割込み要因に割り当てられた割込み（割込み番号256以降）は、さらにグループ割込み要求レジスタの値を調べる。

⑥ 割込みモード設定(SetIntMode)
割込みコントローラ(ICUb)のIRQ コントロールレジスタ(IRQCR)を指定された割込みモードに設定する。
指定可能な割込みモードは以下のように定義される。

#define IM_LEVEL	0x0004		/* Level trigger */
#define IM_EDGE		0x0000		/* Edge trigger */

#define IM_HI		0x0000		/* H level/Interrupt at rising edge */
#define IM_LOW		0x0001		/* L level/Interrupt at falling edge */
#define IM_BOTH		0x0003		/* L level/Interrupt at both edge */

ただし、割込みの種別により指定可能なモードが定められているので、マイコンの仕様書を参照のこと。
グループ割込み要因に割り当てられた割込み（割込み番号256以降）には使用できない。

⑦ 割込みコントローラの割込みマスクレベル設定(SetCtrlIntLevel)
割込みコントローラ(ICUb)に本機能はないため、未実装である。

⑧ 割込みコントローラの割込みマスクレベル取得(GetCtrlIntLevel)
割込みコントローラ(ICUb)に本機能はないため、未実装である。

上記のAPIは以下のファイルに記述される。

    lib/libtk/sysdepend/cpu/core/rxv2/int_rxv2.c

### 2.3.8. OS管理外割込み
最高外部割込み優先度INTPRI_MAX_INT_PRIより優先度の高い外部割込みは、OS管理外割込みとなる。
管理外割込みはOS自体の動作よりも優先して実行される。よって、OSから制御することはできない。また、管理外割込みのハンドラ中でOSのAPIなどの機能を使用することも原則としてできない。
本実装ではINTPRI_MAX_INT_PRIは最高優先度15と定義されている。よって、管理外割込みは存在しない。ただし、割込みおよび無条件トラップ以外の例外は、管理外割込みと同じ扱いとなる。
INTPRI_MAX_INT_PRIを変更することにより管理外割込みをつくることはできる。ただし、管理外割込みハンドラでは原則としてOS機能は使用できないこと、および、OSの実行よりも優先して実行されることを十分考慮する必要がある。

## 2.4. その他の例外
割込みおよび無条件トラップ以外の例外は、本実装ではOSは管理しない。
これらの例外には、暫定的な例外ハンドラを定義している。暫定的な例外ハンドラは、kernel/sysdepend/cpu/core/rxv2/exc_hdr.cの以下の関数として実装されている。

| 例外の種別                | 関数名                 |
| ------------------------- | ---------------------- |
| ノンマスカブル割込み(NMI) | NMI_Handler            |
| アクセス例外              | AccessInst_Handler     |
| 未定義命令例外            | UndefinedInst_Handler  |
| 特権命令例外              | SuperVisorInst_Handler |
| 浮動小数点例外            | FloatingPoint_Handler  |

暫定的な例外ハンドラは、プロファイルUSE_EXCEPTION_DBG_MSGを1に設定にすることにより、デバッグ用の情報を出力する。初期設定は1(有効)である。

必要に応じてユーザが例外ハンドラを記述することにより、各例外に応じた処理を行うことができる。暫定的な例外ハンドラはweak宣言がされているので、ユーザが同名の関数を作成しリンクすることにより、上書きすることができる。

各例外ハンドラは、例外発生時にOSを介さず直接実行される。これらの例外ハンドラはOS管理外例外割込みと同じ扱いとなる。

<div class="page"/>

#  3. システムの起動
##  3.1. 起動処理
###  3.1.1. リセットハンドラ
電源投入またはリセットなどにより、リセットハンドラが実行される。
リセットハンドラは、以下のファイルにReset_Handlerとして実装される。

    kernel/sysdepend/cpu/core/rxv2/reset_hdl.SのReset_Handler

Reset_Handlerでは、マイコンの最小限の初期化を実行したのち、kernel/sysdepend/cpu/core/rxv2/reset_main.cのreset_main関数を実行する。

reset_main関数の処理手順を以下に示す。

(1) ハードウェア初期化（knl_startup_hw）
knl_startup_hw関数を呼出し、リセット時の最小限のハードウェアの初期化を行う。
knl_startup_hwは対象システムごとに実装される。処理内容は各マイコン向けの実装仕様書を参照のこと。

(2) 例外ベクタテーブルの作成
共通実装仕様書を参照のこと。

(3) 変数領域(data, bss)の初期化
共通実装仕様書を参照のこと。

(4) システムメモリ領域の確保
共通実装仕様書を参照のこと。

(5) OS初期化処理(main)の実行
リセット処理を終了するOSの初期化処理(main)を実行し、リセット処理は終了する。

### 3.1.2. OS初期化処理
OS初期化処理は共通部のmain関数で実行される。共通実装仕様書を参照のこと。
main関数から以下のRXv2コアに依存する処理が実行される。

(1) 割込み初期化 (knl_init_interrupt)
OSが使用する割込みの初期化を行う。
以下のファイルにknl_init_interrupt関数として定義される。ただし、本実装では何も処理を行っていない。ユーザは必要に応じて処理を記述する。

    kernel/sysdepend/cpu/core/rxv2/interrupt.c

(2) システムタイマ初期化 (knl_start_hw_timer)
システムタイマのハードウェアに依存した初期化を行う。以下のファイルにknl_start_hw_timerインライン関数として定義される。

     kernel/sysdepend/cpu/core/rxv2/sys_timer.h

本インライン関数では、CMT0タイマをコンフィギュレーションCNF_TIMER_PERIODで指定したシステムタイマの割込み周期で割込みが発生するように設定を行っている。

<div class="page"/>

# 4. システムの終了と再起動
## 4.1. 終了処理と再起動処理
終了処理と再起動処理は共通部のshutdown_system関数で実行される。shutdown_system関数からハードウェアに依存する処理が呼び出される。
対象ハードウェアに依存する処理のうち、RXv2コアに共通の処理を記す。各マイコンに依存する処理は、各マイコン向け実装仕様書を参照のこと。

(1) システムタイマ終了処理 (knl_terminate_hw_timer)
システムタイマのハードウェアに依存した終了化を行う。以下のファイルにknl_terminate_hw_timerインライン関数として定義される。

     kernel/sysdepend/cpu/core/rxv2/sys_timer.h

本インライン関数では、CMT0タイマを停止し、タイマ割込みも発生しないようにする。

<div class="page"/>

# 5. タスク
タスクのRXv2に依存する仕様を以下に記す。各マイコン向け実装仕様書も参照のこと。

## 5.1. タスクの処理ルーチン
タスクの処理ルーチンの実行開始時の各レジスタの状態は以下である。これ以外のレジスタの値は不定である。

| レジスタ | 値                           | 補足              |
| -------- | ---------------------------- | ----------------- |
| PSW      | 0x00010000                   | 割込み許可        |
| R1       | 第一引数 stacd               | タスク起動コード  |
| R2       | 第二引数 *exinf              | タスク拡張情報    |
| SP(R0)   | タスクスタックの先頭アドレス |                   |
| fpsw     | 0x00000100                   | FPU使用時のみ設定 |

## 5.2. タスク・コンテキスト情報
スタック上に保存されるタスクのコンテキスト情報を以下に示す。
SPSWおよびSPCのレジスタの値はディスパッチ時の例外により保存される。R1からR15のレジスタの値はディスパッチャにより保存される。
コンフィギュレーションUSE_FPUが有効の場合、FPSWレジスタの値がディスパッチャにより保存される。
コンフィギュレーションUSE_DSPが有効の場合、ACC1およびACC2レジスタの値がディスパッチャにより保存される。

```
High Address+---------------+
            | SPSW(32bit)   | 
            | SPC(32bit)    | 
            +---------------+ Saved by interrupt entry routines.
            | R15           |
            | R14           |
            | R13           |
            |  :            |
            | R3            |
            | R2            |
        SP->| R1            |
            +---------------+
            | FPSW          | USE_FPU有効時
            +---------------+
            | ACC1(72bit)   | USE_DSP有効時
            | ACC2(72bit)   |
Low Address	+---------------+
```

<div class="page"/>

#  6. 時間管理機能
時間管理機能の本マイコンに依存する仕様を以下に記す。

## 6.1. システムタイマ
本実装では、マイコン内蔵のコンペアマッチタイマ・ユニット0(CMT0)をシステムタイマとして使用する。
システムタイマのティック時間は、1ミリ秒から50ミリ秒の間で設定できる。
ティック時間の標準の設定値は10ミリ秒である。

<div class="page"/>

# 7. 変更履歴
| 版数    | 日付       | 内容                                                    |
| ------- | ---------- | ------------------------------------------------------- |
| 2.00.00 | 2023.12.01 | 新規作成<br>版数は他の仕様書にあわせて2.00.00からとする |